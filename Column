import java.util.*;
/**
 * Represents a column of the board that 
 * is updated when a square within the column
 * is changed.
 * 
 * @author Maria Vazhaeparambil
 * @version May 31, 2018
 */
public class Column implements Section
{
    private int colNum;

    /**
     * Constructor for objects of class Column
     * 
     * @param num the number used to define which column in the sudoku this is
     */
    public Column(int num)
    {
        colNum = num;
    }

    /**
     * Updates the column based on the square that has been changed.
     * 
     * @param  square  the board data that holds all the Sudoku information
     * @param  aSquare the specific square in the board that has been changed
     */
    public void update(Square[][] square, Square aSquare)
    {
        if(aSquare.getCol() == colNum)
        {
            for(int item = 0; item < square[0].length; item++)
            {
                if(square[item][colNum].getValue() != aSquare.getValue())
                    square[item][colNum].removePossibleValue(aSquare.getValue());
            }
        }
    }
    
    /**
     * Returns a pair of possible integers that is the same for two squares in the column.
     * 
     * @param  square  is the board data that holds all Sudoku information
     * 
     * @return array of int of length two that contains the first pair of
     * possible values that occur in two squares of this section;
     * returns null if no such pair exists
     */
    public ArrayList<Integer> get(Square[][] square)
    {
        for(int item = 0; item < square.length; item++)
        {
            ArrayList<Integer> check = square[item][colNum].returnPossible();
            if(check.size() == 2)
            {
                for(int next = item + 1; next < square.length; next++)
                {
                    if(square[next][colNum].returnPossible().equals(check))
                        return check;
                }    
            }
        }
        return null;
    }
    
    /**
     * Removes all other instances of this value in the column.
     * 
     * @param  square is the board data that holds all Sudoku information
     * @param  pair   array of int of length two that contains a pair of
     *                possible values; removes the two values from all squares 
     *                not having the pair as their own possible values
     */
    public void process(Square[][] square, ArrayList<Integer> pair)
    {
        int count = 0;
        for(int r = 0; r < square.length; r++)
        {   
            if(square[r][colNum].returnPossible().equals(pair))
            {
                count++;
            }
        }
        if(count == 2)
        {
            for(int r = 0; r < square.length; r++)
            {   
                if(!square[r][colNum].returnPossible().equals(pair))
                {
                    for(int i = pair.size() - 1; i >= 0; i--)
                        square[r][colNum].removePossibleValue(pair.get(i));
                }
            }
        }
    }
    
    public void get3(Square[][] square)
    {
        for(int item = 0; item < square.length; item++)
        {
            ArrayList<Integer> check = square[item][colNum].returnPossible();
            if(check.size() == 3)
            {
                ArrayList<Square> count = new ArrayList<Square>();
                count.add(square[item][colNum]);
                for(int next = 0; next < square.length; next++)
                {
                    if(next != item && has(check, square[next][colNum].returnPossible()))
                        count.add(square[next][colNum]);
                }   
                if(count.size() == 3)
                    process3(square, count);
            }
        }
    }
    
    /**
     * Removes all other instances of this value in the column.
     * 
     * @param  square is the board data that holds all Sudoku information
     * @param  pair   array of int of length two that contains a pair of
     *                possible values; removes the two values from all squares 
     *                not having the pair as their own possible values
     */
    public void process3(Square[][] square, ArrayList<Square> pair)
    {
        ArrayList<Integer> numbers = new ArrayList<Integer>();
        for(int i = 0; i < pair.size(); i++)
        {
            if(pair.get(i).returnPossible().size() == 3)
            {
                numbers = pair.get(i).returnPossible();
            }
        }
        
        for(int i = 0; i < numbers.size(); i++)
        {
            for(int r = 0; r < square.length; r++)
            {   
                if(r != pair.get(0).getRow() && r != pair.get(1).getRow() && r != pair.get(2).getRow())
                {
                    for(int x = 0; x < square[r][colNum].returnPossible().size(); x++)
                    {
                        if(square[r][colNum].returnPossible().get(x) == numbers.get(i))
                            square[r][colNum].removePossibleValue(numbers.get(i));
                    }
                }
            }
        }
    }
    
    public boolean has(ArrayList<Integer> original, ArrayList<Integer> check)
    {
        int count = 0;
        for(int i = 0; i < check.size(); i++)
        {
            for(int j = 0; j < original.size(); j++)
            {
                if(check.get(i) == original.get(j))
                    count++;
            }
        }
        if(check.size() > original.size())
            return false;
        return count == check.size();
    }
        
    /**
     * Checks whether there is only one possibile location for a number within a column.
     * 
     * @param  square  is the board data that holds all Sudoku information
     */
    public void check(Square[][] square)
    {
        int count = 0;
        int row = -1;
        for(int i = 1; i <= 9; i++)
        {
            for(int r = 0; r < square.length; r++)
            {
                if(square[r][colNum].getValue() == i)
                    count += 2;
                if(square[r][colNum].isPossible(i))
                {
                    count++;
                    row = r;
                }
            }    
            if(count == 1)
            {
                square[row][colNum].setValue(i);
            }
            count = 0;
        }
    }
    
    /**
     * Checks whether the column has one of every number.
     * 
     * @param square is the board data that holds all the Sudoku information
     * 
     * @return true, if the column is complete and has every value, otherwise,
     *          false
     */
    public boolean checkCol(Square[][] square)
    {
        int sum = 0;
        for(int r = 0; r < square.length; r++)
        {
            sum += square[r][colNum].getValue();
        }
        return sum == 45;
    }
    
//     public void nTripleBox(Square[][] square)
//     {
//         ArrayList<Integer> possible = new ArrayList<Integer>();
//         for(int r = 0; r < square.length / 3; r++)
//         {   
//             if(square[r][colNum].returnPossible().size() <= 3
//                 && square[r + 1][colNum].returnPossible().size() <= 3
//                 && square[r + 2][colNum].returnPossible().size() <= 3)
//             {
//                 possible.add(r);
//             }
//         }
//         
//         for(int i = 0; i < possible.size(); i++)
//         {
//             ArrayList<Integer> elim = nTripBoxEnable(square, possible.get(i));
//             if(elim != null)
//                 eliminateBox(square, elim, possible.get(i));
//         }
//     }
//     
//     public void eliminateBox(Square[][] square, ArrayList<Integer> elim, int r)
//     {
//         for(int row = r; row < r + 3; row++)
//         {
//             for(int col = colNum / 3; col < colNum / 3 + 3; col++)
//             {
//                 if(col != colNum)
//                     square[row][col].removePossibleValues(elim);
//             }
//         }
//     }
//     
//     public ArrayList<Integer> nTripBoxEnable(Square[][] square, int r)
//     {
//         ArrayList<Integer> numbers = new ArrayList<Integer>();
//         for(int i = r; i < r + 3; i++)
//         {
//             for(int j = 0; j < square[i][colNum].returnPossible().size(); j++)
//             {
//                 if(checkDuplicatesBox(numbers, square[i][colNum].returnPossible().get(j)))
//                     numbers.add(square[i][colNum].returnPossible().get(j));
//             }
//         }
//         if( numbers.size() <= 3)
//             return numbers;
//         return null;
//     }
//     
//     public boolean checkDuplicatesBox(ArrayList<Integer> numbers, int n)
//     {
//        for(int i = 0; i < numbers.size(); i++)
//        {
//             if(numbers.get(i) == n)
//                 return false;
//        } 
//        return true;
//     }
//    
//     public void nTriple(Square[][] square)
//     {
//         ArrayList<Integer> possible = new ArrayList<Integer>();
//         for(int r = 0; r < 9; r++)
//         {   
//             if(square[r][colNum].returnPossible().size() <= 3)
//             {
//                 possible.add(r);
//             }
//         }
//         
//         for(int i = 0; i < possible.size(); i++)
//         {
//             ArrayList<Integer> elim = nTripEnable(square, possible.get(i));
//             if(elim != null)
//                 eliminate(square, elim, possible.get(i));
//         }
//     }
//     
//     public ArrayList<Integer> nTripEnable(Square[][] square, int r)
//     {
//         ArrayList<Integer> numbers = new ArrayList<Integer>();
//         for(int i = r; i < r + 3; i++)
//         {
//             for(int j = 0; j < square[i][colNum].returnPossible().size(); j++)
//             {
//                 if(checkDuplicates(numbers, square[i][colNum].returnPossible().get(j)))
//                     numbers.add(square[i][colNum].returnPossible().get(j));
//             }
//         }
//         if( numbers.size() <= 3)
//             return numbers;
//         return null;
//     }

public void hiddenDuplicate(Square[][] square)
    {
        ArrayList<Integer> hidden = new ArrayList<Integer>();
        ArrayList<Integer> hasHidden = new ArrayList<Integer>();
        for(int x = 1; x <= 9; x++)
        {   
            int countX = 0;
            for(int r = 0; r < 9; r++)
            {
                if(square[r][colNum].isPossible(x))
                {
                    countX++;
                }
            }
            if(countX == 2)
            {
                for(int r = 0; r < 9; r++)
                {
                    hasHidden.add(r);
                }
                hidden.add(x);
            }
        }
        ArrayList<Integer> attempt = assessDuplicates(hasHidden);
        ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();
        for(int x = 1; x <= 9; x++)
        {
            ArrayList<Integer> together = new ArrayList<Integer>();
            for(int i = 0; i < attempt.size(); i++)
            {
                if(square[attempt.get(i)][colNum].isPossible(x))
                    together.add(attempt.get(i));
            }
            list.add(together);
        }
        for(int i = 0; i < list.size(); i++)
        {
            for(int j = i + 1; j < list.size(); j++)
            {
                if(i == j)
                    runDuplicate(square, list.get(i));
            }
        }
    }
    
    public void runDuplicate(Square[][] square, ArrayList<Integer> remove)
    {
        int[] numbers = new int[9];
        for(int i = 0; i < remove.size(); i++)
        {
            for(int j = 0; j < square[remove.get(i)][colNum].returnPossible().size(); j++)
            {
                numbers[square[remove.get(i)][colNum].returnPossible().get(j) - 1]++;
            }
        }
        for(int i = 0; i < remove.size(); i++)
        {
            for(int x = 0; x < 9; x++)
            {
                if(numbers[x] < 2)
                    square[remove.get(i)][colNum].removePossibleValue(x + 1);
            }
        }
    }
    
    public ArrayList<Integer> assessDuplicates(ArrayList<Integer> hasHidden)
    {
        int[] numbers = new int[9];
        for(int i = 0; i < hasHidden.size(); i++)
        {
            numbers[hasHidden.get(i)]++;
        }
        ArrayList<Integer> attempt = new ArrayList<Integer>();
        for(int i = 0; i < numbers.length; i++)
        {
            if(numbers[i] > 1)
                attempt.add(numbers[i]);
        }
        return attempt;
    }
}
