import java.util.*;
/**
 * Represents a column of the board that 
 * is updated when a square within the column
 * is changed.
 * 
 * @author Maria Vazhaeparambil
 * @version May 31, 2018
 */
public class Row implements Section 
{
    private int rowNum;

    /**
     * Constructor for objects of class Row
     * 
     * @param num the number used to define which row in the sudoku this is
     */
    public Row(int num)
    {
        rowNum = num;
    }

    /**
     * Updates the row based on the square that has been changed.
     * 
     * @param  square  the board data that holds all the Sudoku information
     * @param  aSquare the specific square in the board that has been changed
     */
    public void update(Square[][] square, Square aSquare)
    {
        if(aSquare.getRow() == rowNum)
        {
            for(int item = 0; item < square.length; item++)
            {
                if(square[rowNum][item].getValue() != aSquare.getValue())
                    square[rowNum][item].removePossibleValue(aSquare.getValue());
            }
        }
    }

    /**
     * Returns a pair of possible integers that is the same for two squares in the row.
     *
     * @param  square  is the board data that holds all Sudoku information
     * 
     * @return array of int of length two that contains the first pair of
     * possible values that occur in two squares of this sevtion;
     * returns null if no such pair exists
     */
    public ArrayList<Integer> get(Square[][] square)
    {
        for(int item = 0; item < square[0].length; item++)
        {
            ArrayList<Integer> check = square[rowNum][item].returnPossible();
//             if(rowNum == 2 && item == 2)
//                     System.out.println(square[rowNum][item].returnPossible());
            if(check.size() == 2)
            {
                for(int next = item + 1; next < square[0].length; next++)
                {
                    if(square[rowNum][next].returnPossible().equals(check))
                        return check;
                }
            }
        }
        return null;
    }

    /**
     * Removes all other instances of this value in the row.
     * 
     * @param  square is the board data that holds all Sudoku information
     * @param  pair   array of int of length two that contains a pair of
     *                possible values; removes the two values from all squares 
     *                not having the pair as their own possible values
     */
    public void process(Square[][] square, ArrayList<Integer> pair)
    {
        int count = 0;
        for(int c = 0; c < square[0].length; c++)
        {   
            if(square[rowNum][c].returnPossible().equals(pair))
            {
                count++;
            }
        }
        if(count == 2)
        {
            for(int c = 0; c < square[0].length; c++)
            {   
                if(!square[rowNum][c].returnPossible().equals(pair))
                {
                    for(int i = pair.size() - 1; i >= 0; i--)
                    {
                        square[rowNum][c].removePossibleValue(pair.get(i));
                    }
                }
            }
        }
    }
    
    /**
     * Checks whether there is only one possibile location for a number within a row.
     * 
     * @param  square  is the board data that holds all Sudoku information
     */
    public void check(Square[][] square)
    {
        int count = 0;
        int col = -1;
        for(int i = 1; i <= 9; i++)
        {
            for(int c = 0; c < square[rowNum].length; c++)
            {
                if(square[rowNum][c].getValue() == i)
                    count += 2;
                if(square[rowNum][c].isPossible(i))
                {
                    count++;
                    col = c;
                }
            }    
            if(count == 1)
            {
                square[rowNum][col].setValue(i);
            }
            count = 0;
        }
    }
    
    /**
     * Checks whether the row has one of every number.
     * 
     * @param square is the board data that holds all the Sudoku information
     * 
     * @return true, if the column is complete and has every value, otherwise,
     *          false
     */
    public boolean checkRow(Square[][] square)
    {
        int sum = 0;
        for(int c = 0; c < square[rowNum].length; c++)
        {
            sum += square[rowNum][c].getValue();
        }
        return sum == 45;
    }
    
//     public void nTripleBox(Square[][] square)
//     {
//         ArrayList<Integer> possible = new ArrayList<Integer>();
//         for(int c = 0; c < square.length / 3; c++)
//         {   
//             if(square[rowNum][c].returnPossible().size() <= 3
//                 && square[rowNum][c + 1].returnPossible().size() <= 3
//                 && square[rowNum][c + 2].returnPossible().size() <= 3)
//             {
//                 possible.add(c);
//             }
//         }
//         
//         for(int i = 0; i < possible.size(); i++)
//         {
//             ArrayList<Integer> elim = nTripBoxEnable(square, possible.get(i));
//             if(elim != null)
//                 eliminateBox(square, elim, possible.get(i));
//         }
//     }
//     
//     public void eliminateBox(Square[][] square, ArrayList<Integer> elim, int c)
//     {
//         for(int row = rowNum / 3; row < rowNum / 3 + 3; row++)
//         {
//             for(int col = c; col < c + 3; col++)
//             {
//                 if(row != rowNum)
//                     square[row][col].removePossibleValues(elim);
//             }
//         }
//     }
//     
//     public ArrayList<Integer> nTripBoxEnable(Square[][] square, int c)
//     {
//         ArrayList<Integer> numbers = new ArrayList<Integer>();
//         for(int i = c; i < c + 3; i++)
//         {
//             for(int j = 0; j < square[rowNum][i].returnPossible().size(); j++)
//             {
//                 if(checkDuplicatesBox(numbers, square[rowNum][i].returnPossible().get(j)))
//                     numbers.add(square[rowNum][i].returnPossible().get(j));
//             }
//         }
//         if( numbers.size() <= 3)
//             return numbers;
//         return null;
//     }
//     
//     public boolean checkDuplicatesBox(ArrayList<Integer> numbers, int n)
//     {
//        for(int i = 0; i < numbers.size(); i++)
//        {
//             if(numbers.get(i) == n)
//                 return false;
//        } 
//        return true;
//     }
    
    public void get3(Square[][] square)
    {
        for(int item = 0; item < square.length; item++)
        {
            ArrayList<Integer> check = square[rowNum][item].returnPossible();
            if(check.size() == 3)
            {
                ArrayList<Square> count = new ArrayList<Square>();
                count.add(square[rowNum][item]);
                for(int next = 0; next < square.length; next++)
                {
                    if(next != item && has(check, square[rowNum][next].returnPossible()))
                        count.add(square[rowNum][next]);
                }   
                if(count.size() == 3)
                    process3(square, count);
            }
        }
    }
    
    /**
     * Removes all other instances of this value in the column.
     * 
     * @param  square is the board data that holds all Sudoku information
     * @param  pair   array of int of length two that contains a pair of
     *                possible values; removes the two values from all squares 
     *                not having the pair as their own possible values
     */
    public void process3(Square[][] square, ArrayList<Square> pair)
    {
        ArrayList<Integer> numbers = new ArrayList<Integer>();
        for(int i = 0; i < pair.size(); i++)
        {
            if(pair.get(i).returnPossible().size() == 3)
            {
                numbers = pair.get(i).returnPossible();
            }
        }
        
        for(int i = 0; i < numbers.size(); i++)
        {
            for(int c = 0; c < square.length; c++)
            {   
                if(c != pair.get(0).getRow() && c != pair.get(1).getRow() && c != pair.get(2).getRow())
                {
                    for(int x = 0; x < square[rowNum][c].returnPossible().size(); x++)
                    {
                        if(numbers.size() > i && square[rowNum][c].returnPossible().get(x) == numbers.get(i))
                            square[rowNum][c].removePossibleValue(numbers.get(i));
                    }
                }
            }
        }
    }
    
    public boolean has(ArrayList<Integer> original, ArrayList<Integer> check)
    {
        int count = 0;
        for(int i = 0; i < check.size(); i++)
        {
            for(int j = 0; j < original.size(); j++)
            {
                if(check.get(i) == original.get(j))
                    count++;
            }
        }
        if(check.size() > original.size())
            return false;
        return count == check.size();
    }
    
    public void hiddenDuplicate(Square[][] square)
    {
        ArrayList<Integer> hidden = new ArrayList<Integer>();
        ArrayList<Integer> hasHidden = new ArrayList<Integer>();
        for(int x = 1; x <= 9; x++)
        {   
            int countX = 0;
            for(int c = 0; c < 9; c++)
            {
                if(square[rowNum][c].isPossible(x))
                {
                    countX++;
                }
            }
            if(countX == 2)
            {
                for(int c = 0; c < 9; c++)
                {
                    hasHidden.add(c);
                }
                hidden.add(x);
            }
        }
        ArrayList<Integer> attempt = assessDuplicates(hasHidden);
        ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();
        for(int x = 1; x <= 9; x++)
        {
            ArrayList<Integer> together = new ArrayList<Integer>();
            for(int i = 0; i < attempt.size(); i++)
            {
                if(square[rowNum][attempt.get(i)].isPossible(x))
                    together.add(attempt.get(i));
            }
            list.add(together);
        }
        for(int i = 0; i < list.size(); i++)
        {
            for(int j = i + 1; j < list.size(); j++)
            {
                if(i == j)
                    runDuplicate(square, list.get(i));
            }
        }
    }
    
    public void runDuplicate(Square[][] square, ArrayList<Integer> remove)
    {
        int[] numbers = new int[9];
        for(int i = 0; i < remove.size(); i++)
        {
            for(int j = 0; j < square[rowNum][remove.get(i)].returnPossible().size(); j++)
            {
                numbers[square[rowNum][remove.get(i)].returnPossible().get(j) - 1]++;
            }
        }
        for(int i = 0; i < remove.size(); i++)
        {
            for(int x = 0; x < 9; x++)
            {
                if(numbers[x] < 2)
                    square[rowNum][remove.get(i)].removePossibleValue(x + 1);
            }
        }
    }
    
    public ArrayList<Integer> assessDuplicates(ArrayList<Integer> hasHidden)
    {
        int[] numbers = new int[9];
        for(int i = 0; i < hasHidden.size(); i++)
        {
            numbers[hasHidden.get(i)]++;
        }
        ArrayList<Integer> attempt = new ArrayList<Integer>();
        for(int i = 0; i < numbers.length; i++)
        {
            if(numbers[i] > 1)
                attempt.add(numbers[i]);
        }
        return attempt;
    }
}
